const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/react-plotly-UrmsttJ2.js","assets/index-DHz2mXYI.js","assets/index-BAZwIf1h.css"])))=>i.map(i=>d[i]);
import{k as lt,u as c,C as ut,a as st,D as ct,O as it,_ as ht,e as G,d as M,w as d,B as k}from"./index-DHz2mXYI.js";import{c as B,l as Y,i as J,N as mt,P as j}from"./param-grid-DfNTdoJg.js";import{T as pt}from"./tool-title-BjUzrvD1.js";class vt extends lt{constructor(){super(...arguments),this.state={hasError:!1}}static getDerivedStateFromError(e){return{hasError:!0,error:e}}componentDidCatch(e,r){console.error("Plotly error:",e,r)}render(){return this.state.hasError?c("div",{className:"rounded-md bg-red-50 p-4 text-sm text-red-500 dark:bg-red-950 dark:text-red-400",children:"Failed to render plot. Please try refreshing the page."}):this.props.children}}const dt=it(()=>ht(()=>import("./react-plotly-UrmsttJ2.js").then(t=>t.r),__vite__mapDeps([0,1,2]))),gt=({x:t,yMin:e=0,yMax:r,color:o="gray",width:a=.75,dash:s="dot"})=>({type:"line",x0:t,x1:t,y0:e,y1:r,line:{color:o,width:a,dash:s}}),_t=({x:t,label:e,yref:r="paper",xshift:o=-3,yshift:a=-15,y:s=1,textAngle:n="-90",xanchor:i="right",yanchor:h="top"})=>({text:e,x:t,xshift:o,yshift:a,y:s,yref:r,textangle:n,xanchor:i,yanchor:h,showarrow:!1}),ft=({y:t,xMin:e=0,xMax:r=100,color:o="gray",width:a=.75,dash:s="dot"})=>({type:"line",x0:e,x1:r,y0:t,y1:t,line:{color:o,width:a,dash:s}}),Tt=({className:t})=>c("div",{className:G("flex h-full w-full items-center justify-center rounded-xl bg-muted/20",t),children:c("div",{className:"animate-pulse",children:"Loading plot..."})}),N=ut(({data:t,layout:e,className:r})=>{const{theme:o}=st(),a=o==="dark"?"#09090b":"#ffffff",s=o==="dark"?"#fafafa":"#18181b",n=o==="dark"?"#27272a":"#e4e4e7",i=o==="dark"?"#a1a1aa":"#18181b",h={paper_bgcolor:a,plot_bgcolor:a,font:{color:s},legend:{itemclick:!1,itemdoubleclick:!1},margin:{b:42,l:55,r:10,t:30},xaxis:{gridcolor:n,zeroline:!1,showline:!0,linecolor:i,mirror:!0},yaxis:{gridcolor:n,zeroline:!1,showline:!0,linecolor:i,mirror:!0},showlegend:!0},f={...h,...e,font:{...h.font,...e.font},legend:{...h.legend,...e.legend},margin:{...h.margin,...e.margin},xaxis:{...h.xaxis,...e.xaxis},yaxis:{...h.yaxis,...e.yaxis}},p=t.map(P=>({type:"scatter",mode:"lines",...P}));return c(vt,{children:c(ct,{fallback:c(Tt,{className:r}),children:c(dt,{data:p,layout:f,useResizeHandler:!0,className:G("h-full w-full",r),config:{displaylogo:!1}})})})});Object.defineProperty(N,"displayName",{value:"PlotlyPlot"});function $(t,e){const r=t.length;let o=new Array(r);for(let a=0;a<r;a++)o[a]=t[a]*e;return o}function wt(t,e){const r=t.length;let o=new Array(r);for(let a=0;a<r;a++)o[a]=t[a]+e;return o}function Mt(t){const e=t.length;let r=0;for(let o=0;o<e;o++)r+=t[o];return r}function xt(t){return Mt(t)/t.length}function q(t,e,r){const o=Math.floor((e-t)/r)+1;let a=t,s=new Array(o);for(let n=0;n<o;n++)s[n]=a,a+=r;return s}function C(t,e,r){const o=r.length;let a=new Array(o);const s=e.length-1;let n=0;for(let i=0;i<o;i++){if(r[i]<=e[0]){a[i]=t[0];continue}if(r[i]>=e[s]){a[i]=t[s];continue}for(n;n<s;n++)if(r[i]<e[n+1]){const h=(r[i]-e[n])/(e[n+1]-e[n]);a[i]=t[n]+(t[n+1]-t[n])*h;break}}return a}const yt=[{pwm:1e3,thrust:.196,voltage:21.72,current:.042},{pwm:1001,thrust:.196,voltage:21.72,current:.042},{pwm:1012,thrust:.196,voltage:21.72,current:.041},{pwm:1024,thrust:.196,voltage:21.72,current:.041},{pwm:1038,thrust:.196,voltage:21.72,current:.042},{pwm:1051,thrust:.196,voltage:21.72,current:.042},{pwm:1065,thrust:.196,voltage:21.72,current:.042},{pwm:1078,thrust:.197,voltage:21.72,current:.046},{pwm:1092,thrust:.204,voltage:21.71,current:.315},{pwm:1105,thrust:.237,voltage:21.72,current:.23},{pwm:1118,thrust:.245,voltage:21.72,current:.178},{pwm:1130,thrust:.25,voltage:21.72,current:.187},{pwm:1145,thrust:.261,voltage:21.72,current:.217},{pwm:1158,thrust:.271,voltage:21.72,current:.238},{pwm:1172,thrust:.287,voltage:21.72,current:.297},{pwm:1186,thrust:.303,voltage:21.72,current:.311},{pwm:1198,thrust:.314,voltage:21.71,current:.354},{pwm:1212,thrust:.335,voltage:21.71,current:.428},{pwm:1225,thrust:.358,voltage:21.71,current:.482},{pwm:1239,thrust:.378,voltage:21.71,current:.547},{pwm:1252,thrust:.398,voltage:21.71,current:.608},{pwm:1266,thrust:.418,voltage:21.71,current:.665},{pwm:1279,thrust:.439,voltage:21.71,current:.722},{pwm:1292,thrust:.451,voltage:21.71,current:.771},{pwm:1306,thrust:.472,voltage:21.71,current:.849},{pwm:1319,thrust:.514,voltage:21.7,current:1.025},{pwm:1332,thrust:.546,voltage:21.7,current:1.11},{pwm:1346,thrust:.574,voltage:21.7,current:1.191},{pwm:1360,thrust:.6,voltage:21.7,current:1.302},{pwm:1373,thrust:.624,voltage:21.7,current:1.391},{pwm:1386,thrust:.647,voltage:21.7,current:1.493},{pwm:1400,thrust:.672,voltage:21.7,current:1.584},{pwm:1414,thrust:.699,voltage:21.69,current:1.704},{pwm:1429,thrust:.726,voltage:21.69,current:1.796},{pwm:1443,thrust:.748,voltage:21.69,current:1.919},{pwm:1457,thrust:.774,voltage:21.69,current:2.05},{pwm:1470,thrust:.804,voltage:21.69,current:2.192},{pwm:1484,thrust:.838,voltage:21.69,current:2.369},{pwm:1498,thrust:.872,voltage:21.69,current:2.513},{pwm:1512,thrust:.915,voltage:21.68,current:2.788},{pwm:1526,thrust:.964,voltage:21.67,current:3.025},{pwm:1540,thrust:1.001,voltage:21.67,current:3.215},{pwm:1555,thrust:1.039,voltage:21.68,current:3.482},{pwm:1568,thrust:1.082,voltage:21.67,current:3.699},{pwm:1583,thrust:1.113,voltage:21.67,current:3.851},{pwm:1596,thrust:1.15,voltage:21.66,current:4.103},{pwm:1609,thrust:1.184,voltage:21.66,current:4.386},{pwm:1623,thrust:1.224,voltage:21.65,current:4.57},{pwm:1636,thrust:1.261,voltage:21.65,current:4.808},{pwm:1650,thrust:1.289,voltage:21.65,current:5},{pwm:1664,thrust:1.321,voltage:21.64,current:5.245},{pwm:1676,thrust:1.352,voltage:21.65,current:5.509},{pwm:1690,thrust:1.388,voltage:21.64,current:5.748},{pwm:1704,thrust:1.428,voltage:21.63,current:6.026},{pwm:1717,thrust:1.463,voltage:21.63,current:6.275},{pwm:1730,thrust:1.493,voltage:21.62,current:6.564},{pwm:1746,thrust:1.519,voltage:21.62,current:6.887},{pwm:1759,thrust:1.554,voltage:21.62,current:7.172},{pwm:1773,thrust:1.596,voltage:21.61,current:7.481},{pwm:1786,thrust:1.637,voltage:21.61,current:7.821},{pwm:1800,thrust:1.674,voltage:21.6,current:8.143},{pwm:1814,thrust:1.711,voltage:21.6,current:8.469},{pwm:1827,thrust:1.742,voltage:21.59,current:8.812},{pwm:1840,thrust:1.774,voltage:21.59,current:9.125},{pwm:1854,thrust:1.809,voltage:21.58,current:9.423},{pwm:1867,thrust:1.846,voltage:21.58,current:9.784},{pwm:1881,thrust:1.882,voltage:21.57,current:10.161},{pwm:1895,thrust:1.936,voltage:21.56,current:10.602},{pwm:1909,thrust:1.987,voltage:21.56,current:10.993},{pwm:1923,thrust:2.028,voltage:21.55,current:11.387},{pwm:1937,thrust:2.07,voltage:21.55,current:11.823},{pwm:1950,thrust:2.107,voltage:21.54,current:12.235},{pwm:1963,thrust:2.152,voltage:21.53,current:12.671},{pwm:1977,thrust:2.195,voltage:21.53,current:13.078},{pwm:1989,thrust:2.233,voltage:21.52,current:13.511},{pwm:2e3,thrust:2.254,voltage:21.52,current:13.854}],Ot=.005,X=.001,w=q(0,1,X),K=(t,e,r,o,a,s)=>{function n(l,O,E){return l<O?O:l>E?E:l}function i(l){return l==0}function h(l){return Math.sqrt(l)}function f(l){const T=n(t,-1,1);if(i(T))return 1*l*1;const nt=(T-1+h((1-T)*(1-T)+4*T*1*l))/(2*T);return n(nt*1,0,1)}function p(l){return l=n(l,0,1),e+(r-e)*f(l)}function P(l){return o+(a-o)*l}const x=w.length;let V=new Array(x);for(let l=0;l<x;l++){const O=p(w[l]);V[l]=P(O)}const A=C(s.thrust,s.pwm,V);let y=new Array(x-1);for(let l=0;l<x-1;l++)y[l]=(A[l+1]-A[l])/X;const W=xt(y);let z=0;for(let l=0;l<x-1;l++)z+=(y[l]-W)**2;const ot=Math.sqrt(z/y.length);return{corrected_thrust:A,gradient:y,mean:W,std_deviation:ot,expo:t}},Pt=(t,e,r,o,a)=>q(-1,1,Ot).reduce((n,i)=>{const h=K(i,t,e,r,o,a);return!n||h.std_deviation<n.std_deviation?h:n},null),Q={pwm:0,thrust:0,voltage:0,current:0},_={MOT_PWM_MIN:1e3,MOT_PWM_MAX:2e3,MOT_SPIN_ARM:.1,MOT_SPIN_MIN:.15,MOT_SPIN_MAX:.95,MOT_THST_EXPO:.65},U={MOT_THST_HOVER:0},Z={MOT_THST_HOVER:!0},tt={MOT_THST_EXPO:!1},S=M([]),u=B(),et=M([]),v=B(),I=M(!0),Nt=M(!0),m=M(Array(10).fill(null).map(()=>({...Q}))),R=M(!0),L=(t,e=(...r)=>JSON.stringify(r))=>{const r=new Map;return(...o)=>{const a=e(...o);if(r.has(a))return r.get(a);const s=t(...o);return r.set(a,s),s}},b=(t,e,r)=>e+(r-e)*t,St=()=>yt.map(t=>({pwm:t.pwm,thrust:t.thrust,voltage:t.voltage,current:t.current})),rt=d(()=>m.value.reduce((t,e)=>Math.max(t,e.thrust),0)||1),H=d(()=>{const t=v.value["Number of motors"],e=v.value["All-up weight (AUW)"];return t>0&&e>0?e/t:0}),at=d(()=>S.value.length===0||m.value.length===0?!1:m.value.some(t=>t.thrust>0&&t.pwm>0)),At=t=>{if(!t||typeof t!="object")return!1;const e=t;return typeof e.pwm=="number"&&typeof e.thrust=="number"&&typeof e.voltage=="number"&&typeof e.current=="number"},D=t=>{try{if(!Array.isArray(t)||!t.every(At))throw new Error("invalid thrust data format");m.value=t,R.value=!0}catch(e){console.error("failed to update thrust data:",e)}},F=t=>{if(H.value>0){const e=C(w,t,[H.value])[0],r=Number(e.toFixed(3));Math.abs(r-v.value.MOT_THST_HOVER)>.001&&(v.value.MOT_THST_HOVER=r)}},Et=()=>{D(St()),v.value["All-up weight (AUW)"]=2.5},bt=()=>{D(Array(10).fill(null).map(()=>({...Q}))),u.value.MOT_PWM_MIN=_.MOT_PWM_MIN,u.value.MOT_PWM_MAX=_.MOT_PWM_MAX,u.value.MOT_SPIN_ARM=_.MOT_SPIN_ARM,u.value.MOT_SPIN_MIN=_.MOT_SPIN_MIN,u.value.MOT_SPIN_MAX=_.MOT_SPIN_MAX,u.value.MOT_THST_EXPO=_.MOT_THST_EXPO,v.value["Number of motors"]=4,v.value["All-up weight (AUW)"]=0,v.value.MOT_THST_HOVER=0},It=d(()=>{if(!at.value)return[];const t=m.value,e=t.length,r=new Array(e),o=new Array(e);for(let a=0;a<e;a++)r[a]=t[a].pwm,o[a]=t[a].thrust;return[{x:r,y:o,name:"Measured Thrust"}]}),Rt=L(K),Ht=L(Pt),g=d(()=>{if(!at.value)return null;const t={pwm:m.value.map(r=>r.pwm),thrust:m.value.map(r=>r.thrust),voltage:m.value.map(r=>r.voltage),current:m.value.map(r=>r.current)};if(R.value){const r=Ht(u.value.MOT_SPIN_MIN,u.value.MOT_SPIN_MAX,u.value.MOT_PWM_MIN,u.value.MOT_PWM_MAX,t);return r.expo!==void 0&&!isNaN(r.expo)&&(R.value=!1,u.value.MOT_THST_EXPO=Number(r.expo.toFixed(3))),F(r.corrected_thrust),r}const e=Rt(u.value.MOT_THST_EXPO,u.value.MOT_SPIN_MIN,u.value.MOT_SPIN_MAX,u.value.MOT_PWM_MIN,u.value.MOT_PWM_MAX,t);return F(e.corrected_thrust),e}),Ct=d(()=>g.value?[{x:$(wt(w.slice(0,-1),X*.5),100),y:g.value.gradient,name:`Linearized Thrust<br>Std dev: ${g.value.std_deviation.toFixed(3)}`,line:{color:"indianred"}}]:[]),Xt=d(()=>g.value?{xaxis:{title:"Throttle (%)",range:[0,100]},yaxis:{title:"Thrust gradient (delta thrust / delta throttle)"},showlegend:!0,shapes:g.value.mean?[ft({y:g.value.mean,color:"gray",dash:"4px,3px"})]:[]}:{xaxis:{title:"Throttle (%)"},yaxis:{title:"Thrust gradient (delta thrust / delta throttle)"}}),Lt=L(C),Dt=d(()=>{if(!g.value)return[];const t={pwm:m.value.map(p=>p.pwm),thrust:m.value.map(p=>p.thrust)},e=t.pwm.map(p=>((p-u.value.MOT_PWM_MIN)/(u.value.MOT_PWM_MAX-u.value.MOT_PWM_MIN)-u.value.MOT_SPIN_MIN)/(u.value.MOT_SPIN_MAX-u.value.MOT_SPIN_MIN)),r=Lt(t.thrust,e,w),o=$(w,100),a=Math.max(...g.value.corrected_thrust),s=g.value.corrected_thrust[0],n=a-s,i=o.map(p=>s+n*p/100),h=[{x:o,y:r,name:"Measured Thrust"},{x:o,y:g.value.corrected_thrust,name:"Linearized Thrust"},{x:o,y:i,name:"Ideal Response",line:{dash:"4px,3px",width:1,color:"gray"}}],f=v.value.MOT_THST_HOVER*100;return f>=0&&f<=100&&h.push({x:[f],y:[H.value],name:"THST_HOVER",mode:"markers",marker:{size:8,symbol:"circle",color:"green"}}),h}),Vt=d(()=>{const{MOT_PWM_MIN:t,MOT_PWM_MAX:e}=u.value;return{pwmSpinArm:b(u.value.MOT_SPIN_ARM,t,e),pwmSpinMin:b(u.value.MOT_SPIN_MIN,t,e),pwmSpinMax:b(u.value.MOT_SPIN_MAX,t,e)}}),Wt=d(()=>{if(S.value.length===0)return{xaxis:{title:"ESC Signal (μs)"},yaxis:{title:"Thrust"}};const{pwmSpinArm:t,pwmSpinMin:e,pwmSpinMax:r}=Vt.value,o=rt.value,a=[{x:t,color:"orange",label:"MOT_SPIN_ARM"},{x:e,color:"green",label:"MOT_SPIN_MIN"},{x:r,color:"red",label:"MOT_SPIN_MAX"}];return{xaxis:{title:"ESC Signal (μs)",range:[u.value.MOT_PWM_MIN,u.value.MOT_PWM_MAX]},yaxis:{title:"Thrust",range:[0,o]},shapes:a.map(({x:s,color:n})=>gt({x:s,yMax:o,color:n})),annotations:a.map(({x:s,label:n})=>_t({x:s,label:n}))}}),zt=d(()=>({xaxis:{title:"Throttle (%)",range:[0,100]},yaxis:{title:"Thrust",range:[0,rt.value]},showlegend:!0}));Y(Object.keys(_),_,Z,tt).then(t=>{S.value=t,u.value=J(t)}).catch(t=>{console.error("failed to load thrust expo parameters:",t)}).finally(()=>{I.value=!1});Y(Object.keys(U),U,Z,tt).then(t=>{t.splice(0,0,{Name:"Number of motors",Desc:"Number of thrust producing motors",Value:4,Range:{low:1,high:12}}),t.splice(1,0,{Name:"All-up weight (AUW)",Desc:"All-up weight including battery and payload. Must be same units as thrust data.",Value:0}),et.value=t,v.value=J(t)}).catch(t=>{console.error("Failed to load hover parameters:",t)}).finally(()=>{Nt.value=!1});const kt=[{field:"pwm",headerName:"ESC Signal (μs)",precision:0},{field:"thrust",headerName:"Thrust",precision:3},{field:"voltage",headerName:"Voltage (V)",precision:3},{field:"current",headerName:"Current (A)",precision:3}],Gt=()=>c("div",{className:"max-w-screen-xl pb-8",children:[c(pt,{title:"ArduPilot Thrust Expo",children:"This tool estimates thrust linearization using thrust test stand data. Load a parameter file or enter parameters manually. Copy and paste test stand data from a spreadsheet or enter it manually. Current data is optional (for reference only - not used in calculation). Once the plot is generated, adjust MOT_THST_EXPO to improve the linear fit. If the curve is poorly matched at the extremes, do not chase a perfect fit. Rather, focus on midrange throttle linearity."}),c("div",{className:"flex flex-col gap-3 px-3",children:[c(mt,{title:"Thrust Data",description:"Paste test stand data or drag and drop a CSV or delimited text file.",columns:kt,rows:m,onDataChange:D}),c("div",{className:"flex w-full flex-row flex-wrap justify-between gap-3",children:[c(j,{paramConfig:S,params:u,isLoading:I.value,description:"Manually enter parameters or drag and drop a parameter file.",className:"min-w-[550px] flex-1 basis-[550px]",variant:"narrow"}),c("div",{className:"flex min-w-[550px] flex-1 basis-[550px] flex-col",children:[c("div",{className:"flex-none",children:c(j,{title:"Hover Thrust Estimation",paramConfig:et,params:v,isLoading:I.value,description:"Optional: Enter number of motors and total mass to estimate hover thrust. Use MOT_HOVER_LEARN rather than setting the estimated value explicitly. The learned value may be useful to help validate the generated thrust curve.",variant:"narrow",suppressToolbar:!0})}),c("div",{className:"flex flex-1 flex-col justify-end",children:c("div",{className:"flex justify-end gap-3 pt-3",children:[c(k,{variant:"outline",onClick:Et,children:"Show Example"}),c(k,{variant:"outline",onClick:bt,children:"Reset All"})]})})]})]}),c(N,{className:"h-[450px]",data:It.value,layout:Wt.value}),c(N,{className:"h-[450px]",data:Dt.value,layout:zt.value}),c(N,{className:"h-[450px]",data:Ct.value,layout:Xt.value})]})]});export{Gt as ThrustExpo,Gt as default};
